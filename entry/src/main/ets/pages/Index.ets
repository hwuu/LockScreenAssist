import { QuoteData, Quote } from '../common/QuoteData';
import { QuoteSelectionService } from '../services/QuoteSelectionService';
import { WallpaperService, GeneratedWallpaper, WallpaperStyle, WallpaperOperationResult } from '../services/WallpaperService';
import router from '@ohos.router';
import { ScheduleConfig, WallpaperConfig } from '../common/ScheduleConfig';
import display from '@ohos.display';
import componentSnapshot from '@ohos.arkui.componentSnapshot';
import fs from '@ohos.file.fs';
import image from '@ohos.multimedia.image';
import { BusinessError } from '@ohos.base';
import common from '@ohos.app.ability.common';
import photoAccessHelper from '@ohos.file.photoAccessHelper';
import measure from '@ohos.measure';
// SaveButton is not available in HarmonyOS API, using regular Button instead

// æ–‡æœ¬æµ‹é‡é…ç½®æ¥å£
interface TextMeasureConfig {
  text: string;
  fontSize: number;
  fontFamily: string;
  maxWidth: number;
}

// æ–‡æœ¬æ¢è¡Œç»“æœæ¥å£
interface TextLayoutResult {
  text: string;
  fontSize: number;
  lines: string[];
}

// æ¢è¡Œç‚¹ä¿¡æ¯æ¥å£
interface BreakPoint {
  line: string;
  nextIndex: number;
}

// è¡Œä¿¡æ¯æ¥å£
interface LineInfo {
  text: string;
  width: number;
  height: number;
  characterCount: number;
  hasLeadingPunctuation: boolean;
  isOrphan: boolean;
  isAutoWrapped: boolean;
}

// æ–‡æœ¬å¸ƒå±€åº¦é‡æ¥å£
interface TextLayoutMetrics {
  lines: LineInfo[];
  totalWidth: number;
  totalHeight: number;
  fontSize: number;
  autoWrapCount: number;
  orphanCount: number;
  punctuationViolations: number;
  originalLineCount: number;
}

// æƒé‡é…ç½®æ¥å£
interface WeightsConfig {
  r1: number;  // è‡ªåŠ¨æ¢è¡Œæ¯”ä¾‹
  r2: number;  // å­¤è¡Œæ¯”ä¾‹
  r3: number;  // è¡Œå®½ä¸å‡åŒ€åº¦
  r4: number;  // é•¿å®½æ¯”åå·®
  r5: number;  // ç©ºé—´åˆ©ç”¨ç‡
  r6: number;  // æ ‡ç‚¹ä½ç½®åˆè§„æ€§
  r7: number;  // è§†è§‰å¯†åº¦å‡åŒ€æ€§
  r9: number;  // è§†è§‰ç„¦ç‚¹åˆ†æ•£åº¦
}

// å­—ä½“èŒƒå›´æ¥å£
interface FontRange {
  min: number;
  max: number;
}

// ç†æƒ³è¡Œæ•°èŒƒå›´æ¥å£
interface IdealLineRange {
  min: number;
  max: number;
}

// ä¼˜åŒ–é…ç½®æ¥å£
interface OptimizationConfig {
  weights: WeightsConfig;
  fontRange: FontRange;
  idealLineRange: IdealLineRange;
  maxIterations: number;
}

// æ–‡æœ¬å¸ƒå±€ä¼˜åŒ–å™¨ç±»
class TextLayoutOptimizer {
  private config: OptimizationConfig;
  private screenWidth: number;
  private screenHeight: number;

  constructor(screenWidth: number, screenHeight: number) {
    this.screenWidth = screenWidth;
    this.screenHeight = screenHeight;

    const weights: WeightsConfig = {
      r1: 0.15,  // è‡ªåŠ¨æ¢è¡Œæ¯”ä¾‹
      r2: 0.35,  // å­¤è¡Œæ¯”ä¾‹
      r3: 0.05,  // è¡Œå®½ä¸å‡åŒ€åº¦
      r4: 0.05,  // é•¿å®½æ¯”åå·®
      r5: 0.15,  // ç©ºé—´åˆ©ç”¨ç‡
      r6: 0.1,   // æ ‡ç‚¹ä½ç½®åˆè§„æ€§
      r7: 0.125, // è§†è§‰å¯†åº¦å‡åŒ€æ€§
      r9: 0.025  // è§†è§‰ç„¦ç‚¹åˆ†æ•£åº¦
    };

    const fontRange: FontRange = { min: 14, max: 40 };
    const idealLineRange: IdealLineRange = { min: 5, max: 12 };

    this.config = {
      weights: weights,
      fontRange: fontRange,
      idealLineRange: idealLineRange,
      maxIterations: 50
    };
  }

  // ä¸»è¦ä¼˜åŒ–æ–¹æ³•
  optimizeLayout(text: string, containerWidth: number, baseFontSize: number): TextLayoutResult {
    let bestScore = Infinity;
    let bestResult: TextLayoutResult | null = null;

    // ä¸¤é˜¶æ®µæœç´¢ï¼šç²—æœç´¢ + ç»†æœç´¢
    const coarseRange = this.getCoarseSearchRange(baseFontSize);
    let coarseBest = this.searchOptimalFontSize(text, containerWidth, coarseRange.min, coarseRange.max, 2);

    // åœ¨æœ€ä½³åŒºé—´è¿›è¡Œç»†æœç´¢
    const fineRange: FontRange = {
      min: Math.max(this.config.fontRange.min, coarseBest.fontSize - 4),
      max: Math.min(this.config.fontRange.max, coarseBest.fontSize + 4)
    };
    let fineBest = this.searchOptimalFontSize(text, containerWidth, fineRange.min, fineRange.max, 0.5);

    return fineBest;
  }

  // æœç´¢æœ€ä½³å­—ä½“å¤§å°
  private searchOptimalFontSize(text: string, containerWidth: number, minSize: number, maxSize: number, step: number): TextLayoutResult {
    let bestScore = Infinity;
    let bestResult: TextLayoutResult | null = null;

    console.log(`=== å¼€å§‹æœç´¢æœ€ä½³å­—ä½“å¤§å° ===`);
    console.log(`æ–‡æœ¬: "${text}"`);
    console.log(`å®¹å™¨å®½åº¦: ${containerWidth}px`);
    console.log(`å­—ä½“èŒƒå›´: ${minSize}px - ${maxSize}px, æ­¥é•¿: ${step}px`);

    for (let fontSize = minSize; fontSize <= maxSize; fontSize += step) {
      const metrics = this.measureText(text, fontSize, containerWidth);
      const score = this.calculateScore(metrics);

      const r1 = this.calculateR1(metrics);
      const r2 = this.calculateR2(metrics);
      const r3 = this.calculateR3(metrics);
      const r4 = this.calculateR4(metrics);
      const r5 = this.calculateR5(metrics);
      const r6 = this.calculateR6(metrics);
      const r7 = this.calculateR7(metrics);
      const r9 = this.calculateR9(metrics);

      console.log(`--- å­—ä½“å¤§å° ${fontSize}px ---`);
      console.log(`æ€»è¡Œæ•°: ${metrics.lines.length}`);
      console.log(`å­¤è¡Œæ•°: ${metrics.orphanCount}`);
      console.log(`è‡ªåŠ¨æ¢è¡Œæ•°: ${metrics.autoWrapCount}`);
      console.log(`æ ‡ç‚¹è¿è§„æ•°: ${metrics.punctuationViolations}`);
      console.log(`æ–‡æœ¬åŒºåŸŸ: ${metrics.totalWidth.toFixed(0)}x${metrics.totalHeight.toFixed(0)}px`);
      console.log(`å„æŒ‡æ ‡è¯„åˆ†:`);
      console.log(`  r1(è‡ªåŠ¨æ¢è¡Œ): ${r1.toFixed(4)} * ${this.config.weights.r1} = ${(r1 * this.config.weights.r1).toFixed(4)}`);
      console.log(`  r2(å­¤è¡Œ): ${r2.toFixed(4)} * ${this.config.weights.r2} = ${(r2 * this.config.weights.r2).toFixed(4)}`);
      console.log(`  r3(è¡Œå®½ä¸å‡): ${r3.toFixed(4)} * ${this.config.weights.r3} = ${(r3 * this.config.weights.r3).toFixed(4)}`);
      console.log(`  r4(é•¿å®½æ¯”): ${r4.toFixed(4)} * ${this.config.weights.r4} = ${(r4 * this.config.weights.r4).toFixed(4)}`);
      console.log(`  r5(ç©ºé—´åˆ©ç”¨): ${r5.toFixed(4)} * ${this.config.weights.r5} = ${(r5 * this.config.weights.r5).toFixed(4)}`);
      console.log(`  r6(æ ‡ç‚¹ä½ç½®): ${r6.toFixed(4)} * ${this.config.weights.r6} = ${(r6 * this.config.weights.r6).toFixed(4)}`);
      console.log(`  r7(å¯†åº¦å‡åŒ€): ${r7.toFixed(4)} * ${this.config.weights.r7} = ${(r7 * this.config.weights.r7).toFixed(4)}`);
      console.log(`  r9(ç„¦ç‚¹åˆ†æ•£): ${r9.toFixed(4)} * ${this.config.weights.r9} = ${(r9 * this.config.weights.r9).toFixed(4)}`);
      console.log(`ç»¼åˆè¯„åˆ†: ${score.toFixed(4)}`);

      // è¾“å‡ºæ¯è¡Œçš„è¯¦ç»†ä¿¡æ¯
      metrics.lines.forEach((line, index) => {
        console.log(`è¡Œ${index + 1}: "${line.text}" (å®½åº¦:${line.width.toFixed(1)}px, å­—ç¬¦æ•°:${line.characterCount}, å­¤è¡Œ:${line.isOrphan}, è‡ªåŠ¨æ¢è¡Œ:${line.isAutoWrapped})`);
      });

      if (score < bestScore) {
        bestScore = score;
        bestResult = {
          text: metrics.lines.map(line => line.text).join('\n'),
          fontSize: fontSize,
          lines: metrics.lines.map(line => line.text)
        };

        console.log(`âœ“ æ–°çš„æœ€ä½³ç»“æœ! å­—ä½“å¤§å°: ${fontSize}px, è¯„åˆ†: ${score.toFixed(4)}`);
      }
    }

    console.log(`=== æœç´¢å®Œæˆ ===`);
    if (bestResult) {
      // ä¸ºäº†è¿›ä¸€æ­¥ç¡®ä¿èƒ½æ¶ˆé™¤å­¤è¡Œï¼Œå°† fontSize å‡å°ä¸€ç‚¹ã€‚
      if (bestResult.fontSize > minSize) {
        bestResult.fontSize -= 1;
      }
      console.log(`æœ€ç»ˆç»“æœ - å­—ä½“å¤§å°: ${bestResult.fontSize}px, è¡Œæ•°: ${bestResult.lines.length}`);
      console.log(`æœ€ç»ˆæ–‡æœ¬:\n${bestResult.text}`);
    }

    return bestResult || {
      text: text,
      fontSize: minSize,
      lines: [text]
    };
  }

  // è·å–ç²—æœç´¢èŒƒå›´
  private getCoarseSearchRange(baseFontSize: number): FontRange {
    const range = 8; // åŸºå‡†å­—ä½“å¤§å°ä¸Šä¸‹8px
    const result: FontRange = {
      min: Math.max(this.config.fontRange.min, baseFontSize - range),
      max: Math.min(this.config.fontRange.max, baseFontSize + range)
    };
    return result;
  }

  // è®¡ç®—ç»¼åˆè¯„åˆ†
  private calculateScore(metrics: TextLayoutMetrics): number {
    const r1 = this.calculateR1(metrics);
    const r2 = this.calculateR2(metrics);
    const r3 = this.calculateR3(metrics);
    const r4 = this.calculateR4(metrics);
    const r5 = this.calculateR5(metrics);
    const r6 = this.calculateR6(metrics);
    const r7 = this.calculateR7(metrics);
    const r9 = this.calculateR9(metrics);

    return this.config.weights.r1 * r1 +
           this.config.weights.r2 * r2 +
           this.config.weights.r3 * r3 +
           this.config.weights.r4 * r4 +
           this.config.weights.r5 * r5 +
           this.config.weights.r6 * r6 +
           this.config.weights.r7 * r7 +
           this.config.weights.r9 * r9;
  }

  // æ ¸å¿ƒæ–‡æœ¬æµ‹é‡æ–¹æ³•
  private measureText(text: string, fontSize: number, containerWidth: number): TextLayoutMetrics {
    console.log(`>>> measureTextå¼€å§‹: å­—ä½“${fontSize}px, å®¹å™¨å®½åº¦${containerWidth}px`);
    console.log(`åŸå§‹æ–‡æœ¬: "${text}"`);

    // 1. é¦–å…ˆåº”ç”¨å¼ºåˆ¶æ ‡ç‚¹æ¢è¡Œé€»è¾‘ï¼Œè·å–åŸå§‹è¡Œæ•°
    const punctuationFormatted = text
      .replace(/([ï¼Œ,])\s*/g, '$1\n')
      .replace(/([ã€‚ï¼ï¼Ÿï¼›ï¼š])\s*/g, '$1\n \n')
      .replace(/([.!?;:])\s*/g, '$1\n \n')
      .replace(/\n{3,}/g, '\n \n')
      .replace(/\s*\n\s*/g, '\n')
      .trim();

    console.log(`æ ‡ç‚¹æ¢è¡Œå: "${punctuationFormatted}"`);

    const originalLines = punctuationFormatted.split('\n').filter(line => line.trim().length > 0);
    const originalLineCount = originalLines.length;

    console.log(`åŸå§‹è¡Œæ•°: ${originalLineCount}`);
    originalLines.forEach((line, index) => {
      console.log(`åŸå§‹è¡Œ${index + 1}: "${line}"`);
    });

    // 2. å¯¹æ¯ä¸€è¡Œè¿›è¡Œæ™ºèƒ½æ¢è¡Œå¤„ç†
    let allLines: LineInfo[] = [];
    let autoWrapCount = 0;
    let maxWidth = 0;
    let totalHeight = 0;

    for (let i = 0; i < originalLines.length; i++) {
      const originalLine = originalLines[i];
      if (originalLine.trim().length === 0) continue;

      // æµ‹é‡è¿™ä¸€è¡Œåœ¨å®¹å™¨å®½åº¦ä¸‹çš„æ¢è¡Œæƒ…å†µ
      const wrappedLines = this.wrapSingleLine(originalLine, fontSize, containerWidth);

      for (let j = 0; j < wrappedLines.length; j++) {
        const lineText = wrappedLines[j];
        const lineWidth = this.measureSingleLineWidth(lineText, fontSize);
        const lineHeight = fontSize * 1.2; // è¡Œé«˜ç³»æ•°

        const lineInfo: LineInfo = {
          text: lineText,
          width: lineWidth,
          height: lineHeight,
          characterCount: lineText.length,
          hasLeadingPunctuation: this.hasLeadingPunctuation(lineText),
          isOrphan: this.isOrphanLine(lineText),
          isAutoWrapped: j > 0 // é™¤äº†ç¬¬ä¸€è¡Œï¼Œå…¶ä»–éƒ½æ˜¯è‡ªåŠ¨æ¢è¡Œäº§ç”Ÿçš„
        };

        allLines.push(lineInfo);
        maxWidth = Math.max(maxWidth, lineWidth);
        totalHeight += lineHeight;

        // ç»Ÿè®¡è‡ªåŠ¨æ¢è¡Œæ•°é‡
        if (j > 0) {
          autoWrapCount++;
        }
      }
    }

    // 3. ç»Ÿè®¡å„ç§æŒ‡æ ‡
    const orphanCount = allLines.filter(line => line.isOrphan).length;
    const punctuationViolations = allLines.filter(line => line.hasLeadingPunctuation).length;

    return {
      lines: allLines,
      totalWidth: maxWidth,
      totalHeight: totalHeight,
      fontSize: fontSize,
      autoWrapCount: autoWrapCount,
      orphanCount: orphanCount,
      punctuationViolations: punctuationViolations,
      originalLineCount: originalLineCount
    };
  }

  // å¯¹å•è¡Œæ–‡æœ¬è¿›è¡Œæ™ºèƒ½æ¢è¡Œ
  private wrapSingleLine(text: string, fontSize: number, maxWidth: number): string[] {
    if (!text || text.trim().length === 0) return [];

    console.log(`>>> wrapSingleLineå¼€å§‹: "${text}", å­—ä½“${fontSize}px, æœ€å¤§å®½åº¦${maxWidth}px`);

    const lines: string[] = [];
    let currentLine = '';
    let i = 0;

    // æ ‡ç‚¹ç¬¦å·è§„åˆ™
    const punctuationAtStart = /^[ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼šã€ï¼‰ã€‘ã€ã€ã€‹\"'â€¦]/;
    const punctuationAtEnd = /[ï¼ˆã€ã€Œã€ã€Š\"']$/;

    while (i < text.length) {
      const char = text[i];
      const testLine = currentLine + char;
      const lineWidth = this.measureSingleLineWidth(testLine, fontSize);

      console.log(`å­—ç¬¦'${char}': æµ‹è¯•è¡Œ"${testLine}" å®½åº¦${lineWidth.toFixed(1)}px, æœ€å¤§å®½åº¦${maxWidth}px`);

      if (lineWidth > maxWidth && currentLine.length > 0) {
        console.log(`éœ€è¦æ¢è¡Œ! å½“å‰è¡Œ"${currentLine}" å®½åº¦è¶…é™`);
        // éœ€è¦æ¢è¡Œï¼Œæ£€æŸ¥æ¢è¡Œè§„åˆ™
        const breakResult = this.findOptimalBreakPointNew(
          text, currentLine, i, fontSize, maxWidth
        );

        lines.push(breakResult.line);
        console.log(`æ·»åŠ è¡Œ: "${breakResult.line}"`);
        currentLine = '';
        i = breakResult.nextIndex;
        continue;
      }

      currentLine += char;
      i++;
    }

    if (currentLine.length > 0) {
      lines.push(currentLine);
      console.log(`æ·»åŠ æœ€åä¸€è¡Œ: "${currentLine}"`);
    }

    console.log(`<<< wrapSingleLineå®Œæˆ: æ€»å…±${lines.length}è¡Œ`);
    return lines.length > 0 ? lines : [text];
  }

  // æµ‹é‡å•è¡Œæ–‡æœ¬å®½åº¦
  private measureSingleLineWidth(text: string, fontSize: number): number {
    try {
      const textMetrics = measure.measureTextSize({
        textContent: text,
        fontSize: fontSize,
        fontFamily: 'HarmonyOS Sans'
      });

      const width = textMetrics.width;
      let result: number;

      if (typeof width === 'number') {
        result = width;
      } else if (typeof width === 'string') {
        const numericValue = parseFloat(width);
        result = isNaN(numericValue) ? text.length * fontSize * 0.9 : numericValue;
      } else {
        result = text.length * fontSize * 0.9;
      }

      /*
      // å¯¹å…³é”®æ–‡æœ¬ï¼ˆå¦‚æˆ‘ä»¬çš„æµ‹è¯•å¥å­ï¼‰è¾“å‡ºè¯¦ç»†æ—¥å¿—
      if (text.includes('ä¸€åˆ‡ç¾¤ä¼—çš„å®é™…ç”Ÿæ´»é—®é¢˜') || text.includes('éƒ½æ˜¯æˆ‘ä»¬åº”å½“æ³¨æ„çš„é—®é¢˜')) {
        console.log(`ğŸ” å…³é”®æ–‡æœ¬æµ‹é‡: "${text}" å­—ä½“${fontSize}px = ${result.toFixed(1)}px (åŸå§‹å€¼: ${width}, ç±»å‹: ${typeof width})`);
      }
      */

      // æ·»åŠ è¯¦ç»†æ—¥å¿—ç”¨äºè°ƒè¯•
      if (text.length <= 3) { // åªå¯¹çŸ­æ–‡æœ¬è¾“å‡ºè¯¦ç»†æ—¥å¿—ï¼Œé¿å…æ—¥å¿—è¿‡å¤š
        console.log(`measureSingleLineWidth: "${text}" å­—ä½“${fontSize}px = ${result.toFixed(1)}px (åŸå§‹å€¼: ${width}, ç±»å‹: ${typeof width})`);
      }

      return result;
    } catch (error) {
      console.error('Failed to measure text width:', error);
      const fallback = text.length * fontSize * 0.9;
      console.log(`measureSingleLineWidth fallback: "${text}" å­—ä½“${fontSize}px = ${fallback.toFixed(1)}px`);
      return fallback;
    }
  }

  // æ–°çš„å¯»æ‰¾æœ€ä½³æ¢è¡Œç‚¹æ–¹æ³•
  private findOptimalBreakPointNew(
    fullText: string,
    currentLine: string,
    currentIndex: number,
    fontSize: number,
    maxWidth: number
  ): BreakPoint {
    const nextChar = fullText[currentIndex] || '';
    const punctuationAtStart = /[ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼šã€ï¼‰ã€‘ã€ã€ã€‹\"'â€¦]/;
    const punctuationAtEnd = /[ï¼ˆã€ã€Œã€ã€Š\"']/;

    if (punctuationAtStart.test(nextChar)) {
      const testLine = currentLine + nextChar;
      const totalWidth = this.measureSingleLineWidth(testLine, fontSize);

      if (totalWidth <= maxWidth) {
        return {
          line: testLine,
          nextIndex: currentIndex + 1
        };
      } else {
        return this.findPreviousBreakPointNew(currentLine, currentIndex, fontSize, maxWidth);
      }
    }

    const lastChar = currentLine[currentLine.length - 1] || '';
    if (punctuationAtEnd.test(lastChar)) {
      return this.findPreviousBreakPointNew(currentLine, currentIndex, fontSize, maxWidth);
    }

    return {
      line: currentLine,
      nextIndex: currentIndex
    };
  }

  // æ–°çš„å‘å‰å›é€€å¯»æ‰¾æ–­ç‚¹æ–¹æ³•
  private findPreviousBreakPointNew(
    currentLine: string,
    currentIndex: number,
    fontSize: number,
    maxWidth: number
  ): BreakPoint {
    for (let i = currentLine.length - 1; i > 0; i--) {
      const truncatedLine = currentLine.substring(0, i);
      const char = currentLine[i];

      const punctuationAtEnd = /[ï¼ˆã€ã€Œã€ã€Š\"']/;
      const punctuationAtStart = /[ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼šã€ï¼‰ã€‘ã€ã€ã€‹\"'â€¦]/;

      if (!punctuationAtEnd.test(truncatedLine[truncatedLine.length - 1] || '') &&
          !punctuationAtStart.test(char)) {

        const truncatedWidth = this.measureSingleLineWidth(truncatedLine, fontSize);

        if (truncatedWidth <= maxWidth) {
          return {
            line: truncatedLine,
            nextIndex: currentIndex - (currentLine.length - i)
          };
        }
      }
    }

    return {
      line: currentLine,
      nextIndex: currentIndex
    };
  }

  // æ£€æŸ¥æ˜¯å¦æœ‰è¡Œé¦–æ ‡ç‚¹
  private hasLeadingPunctuation(line: string): boolean {
    const punctuationAtStart = /^[ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼šã€ï¼‰ã€‘ã€ã€ã€‹\"'â€¦]/;
    return punctuationAtStart.test(line);
  }

  // æ£€æŸ¥æ˜¯å¦ä¸ºå­¤è¡Œ
  private isOrphanLine(line: string): boolean {
    const effectiveLength = line.replace(/[ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼šã€ï¼ˆï¼‰ã€ã€‘ã€Œã€ã€ã€ã€Šã€‹\"'\"'â€¦]/g, '').length;
    const isOrphan = effectiveLength > 0 && effectiveLength < 3;
    if (isOrphan) {
      console.log(`æ£€æµ‹åˆ°å­¤è¡Œ: "${line}" (æœ‰æ•ˆå­—ç¬¦æ•°: ${effectiveLength})`);
    }
    return isOrphan;
  }

  // r1: è‡ªåŠ¨æ¢è¡Œæ¯”ä¾‹ = (è‡ªåŠ¨æ¢è¡Œæ•° + åŸå§‹æ¢è¡Œæ•°) / æ¸²æŸ“åæ€»è¡Œæ•°
  private calculateR1(metrics: TextLayoutMetrics): number {
    if (metrics.lines.length === 0) return 0;
    return (metrics.autoWrapCount + metrics.originalLineCount) / metrics.lines.length;
  }

  // r2: å­¤è¡Œæ¯”ä¾‹ = å­¤è¡Œæ•°é‡ / æ¸²æŸ“åæ€»è¡Œæ•°
  private calculateR2(metrics: TextLayoutMetrics): number {
    if (metrics.lines.length === 0) return 0;
    return metrics.orphanCount / metrics.lines.length;
  }

  // r6: æ ‡ç‚¹ç¬¦å·ä½ç½®åˆè§„æ€§ = è¡Œé¦–æ ‡ç‚¹æ•°é‡ / æ€»è¡Œæ•°
  private calculateR6(metrics: TextLayoutMetrics): number {
    if (metrics.lines.length === 0) return 0;
    return metrics.punctuationViolations / metrics.lines.length;
  }

  // r7: è§†è§‰å¯†åº¦å‡åŒ€æ€§ = å„è¡Œå­—ç¬¦å¯†åº¦æ–¹å·® / å¹³å‡å­—ç¬¦å¯†åº¦
  private calculateR7(metrics: TextLayoutMetrics): number {
    if (metrics.lines.length <= 1) return 0;

    // è®¡ç®—æ¯è¡Œçš„å­—ç¬¦å¯†åº¦ï¼ˆå­—ç¬¦æ•°/è¡Œå®½åº¦ï¼‰
    const densities: number[] = [];
    for (const line of metrics.lines) {
      if (line.width > 0) {
        densities.push(line.characterCount / line.width);
      }
    }

    if (densities.length <= 1) return 0;

    // è®¡ç®—å¹³å‡å¯†åº¦
    const meanDensity = densities.reduce((sum, d) => sum + d, 0) / densities.length;
    if (meanDensity === 0) return 0;

    // è®¡ç®—æ–¹å·®
    const variance = densities.reduce((sum, d) => sum + Math.pow(d - meanDensity, 2), 0) / densities.length;

    return variance / meanDensity;
  }

  // r3: è¡Œå®½ä¸å‡åŒ€åº¦ = 1 - (æœ€çŸ­è¡Œå®½åº¦ / æœ€å®½è¡Œå®½åº¦)
  private calculateR3(metrics: TextLayoutMetrics): number {
    if (metrics.lines.length <= 1) return 0;

    let minWidth = Infinity;
    let maxWidth = 0;

    for (const line of metrics.lines) {
      if (line.width > 0) {
        minWidth = Math.min(minWidth, line.width);
        maxWidth = Math.max(maxWidth, line.width);
      }
    }

    if (maxWidth === 0 || minWidth === Infinity) return 0;
    return 1 - (minWidth / maxWidth);
  }

  // r4: é•¿å®½æ¯”åå·® = abs(æ¸²æŸ“åæ–‡æœ¬åŒºåŸŸé•¿å®½æ¯” - å±å¹•é•¿å®½æ¯”) / å±å¹•é•¿å®½æ¯”
  private calculateR4(metrics: TextLayoutMetrics): number {
    if (metrics.totalWidth === 0 || metrics.totalHeight === 0 || this.screenWidth === 0 || this.screenHeight === 0) return 0;

    // è®¡ç®—æ–‡æœ¬åŒºåŸŸé•¿å®½æ¯”ï¼ˆé«˜/å®½ï¼‰
    const textAspectRatio = metrics.totalHeight / metrics.totalWidth;

    // è®¡ç®—å±å¹•é•¿å®½æ¯”ï¼ˆé«˜/å®½ï¼‰
    const screenAspectRatio = this.screenHeight / this.screenWidth;

    if (screenAspectRatio === 0) return 0;
    return Math.abs(textAspectRatio - screenAspectRatio) / screenAspectRatio;
  }

  // r5: ç©ºé—´åˆ©ç”¨ç‡ = (å±å¹•é¢ç§¯ - æ¸²æŸ“åæ–‡æœ¬åŒºåŸŸé¢ç§¯) / å±å¹•é¢ç§¯
  private calculateR5(metrics: TextLayoutMetrics): number {
    if (this.screenWidth === 0 || this.screenHeight === 0) return 0;

    const screenArea = this.screenWidth * this.screenHeight;
    const textArea = metrics.totalWidth * metrics.totalHeight;

    return (screenArea - textArea) / screenArea;
  }

  // r9: è§†è§‰ç„¦ç‚¹åˆ†æ•£åº¦ = |ç†æƒ³è¡Œæ•° - å®é™…è¡Œæ•°| / ç†æƒ³è¡Œæ•°
  private calculateR9(metrics: TextLayoutMetrics): number {
    const actualLines = metrics.lines.length;
    const idealLines = (this.config.idealLineRange.min + this.config.idealLineRange.max) / 2;

    if (idealLines === 0) return 0;
    return Math.abs(idealLines - actualLines) / idealLines;
  }
}

// æ•°æ®æºç±»å®ç°ï¼Œå‚è€ƒhelper6_page_turn.txtç¬¬68-74è¡Œ
class QuoteDataSource implements IDataSource {
  private quotes: Quote[] = [];
  private listeners: DataChangeListener[] = [];

  public totalCount(): number {
    return this.quotes.length;
  }

  public getData(index: number): Quote {
    return this.quotes[index];
  }

  public registerDataChangeListener(listener: DataChangeListener): void {
    if (this.listeners.indexOf(listener) < 0) {
      this.listeners.push(listener);
    }
  }

  public unregisterDataChangeListener(listener: DataChangeListener): void {
    const pos = this.listeners.indexOf(listener);
    if (pos >= 0) {
      this.listeners.splice(pos, 1);
    }
  }

  public pushItem(quote: Quote): void {
    this.quotes.push(quote);
    this.notifyDataAdd(this.quotes.length - 1);
  }

  public addItem(quote: Quote): void {
    this.quotes.unshift(quote);
    this.notifyDataAdd(0);
  }

  private notifyDataAdd(index: number): void {
    this.listeners.forEach(listener => {
      listener.onDataAdd(index);
    });
  }
}

@Entry
@Component
struct Index {
  @State currentQuote: Quote | null = null;
  @State currentWallpaper: GeneratedWallpaper | null = null;
  @State isLoading: boolean = false;
  @State previewBackground: string = '';
  @State previewMode: 'current' | 'recommended' = 'current';
  @State recommendedQuote: Quote | null = null;
  @State recommendedWallpaper: GeneratedWallpaper | null = null;
  @State usedRecommendations: Set<string> = new Set();

  @State config: WallpaperConfig | null = null;
  @State showSaveDialog: boolean = false;
  @State screenRatio: number = 16/9; // é»˜è®¤æ¯”ä¾‹
  @State screenWidth: number = 0;
  @State screenHeight: number = 0;
  @State setLockScreen: boolean = false; // å®˜æ–¹å·²ä¸æ”¯æŒè¯¥åŠŸèƒ½
  @State saveToGallery: boolean = true; // é»˜è®¤é€‰ä¸­ä¿å­˜åˆ°å›¾åº“
  @State isApplying: boolean = false; // åº”ç”¨å£çº¸çš„çŠ¶æ€
  @State hintOpacity: number = 0; // æç¤ºæ–‡å­—é€æ˜åº¦
  @State contentOpacity: number = 1; // å†…å®¹åŒºåŸŸé€æ˜åº¦
  @State isTransitioning: boolean = false; // æ˜¯å¦åœ¨è¿‡æ¸¡åŠ¨ç”»ä¸­
  private hintTimer: number = -1; // æç¤ºæ–‡å­—å®šæ—¶å™¨
  private debounceTimer: number = -1; // é˜²æŠ–å®šæ—¶å™¨
  private blinkTimer: number = -1; // é—ªçƒåŠ¨ç”»å®šæ—¶å™¨
  @State isBlinking: boolean = false; // æ˜¯å¦æ­£åœ¨é—ªçƒ

  // ä¸Šä¸‹ç¿»é¡µç›¸å…³çŠ¶æ€
  @State currentPageIndex: number = 0;
  @State quoteDataSource: QuoteDataSource = new QuoteDataSource();
  @State wallpaperList: (GeneratedWallpaper | null)[] = [];
  @State optimizedFontSizes: number[] = []; // å­˜å‚¨æ¯é¡µä¼˜åŒ–åçš„å­—ä½“å¤§å°
  private textLayoutOptimizer: TextLayoutOptimizer | null = null; // æ–‡æœ¬å¸ƒå±€ä¼˜åŒ–å™¨
  private usedQuoteTexts: Set<string> = new Set(); // å·²ä½¿ç”¨çš„quoteæ–‡æœ¬é›†åˆï¼Œç”¨äºå»é‡

  // æµ‹é‡æ–‡æœ¬å®½åº¦çš„æ–¹æ³•
  private measureTextWidth(config: TextMeasureConfig): number {
    try {
      const textMetrics = measure.measureTextSize({
        textContent: config.text,
        fontSize: config.fontSize,
        fontFamily: config.fontFamily
      });
      // å°†Lengthç±»å‹è½¬æ¢ä¸ºnumber
      const width = textMetrics.width;
      if (typeof width === 'number') {
        return width;
      } else if (typeof width === 'string') {
        // å¦‚æœæ˜¯å­—ç¬¦ä¸²å½¢å¼ï¼ˆå¦‚"100px"ï¼‰ï¼Œæå–æ•°å€¼éƒ¨åˆ†
        const numericValue = parseFloat(width);
        return isNaN(numericValue) ? config.text.length * config.fontSize * 0.9 : numericValue;
      } else {
        // å…¶ä»–æƒ…å†µé™çº§åˆ°ä¼°ç®—
        return config.text.length * config.fontSize * 0.9;
      }
    } catch (error) {
      console.error('Failed to measure text:', error);
      // é™çº§åˆ°ä¼°ç®—æ–¹æ³•
      return config.text.length * config.fontSize * 0.9;
    }
  }

  // æ™ºèƒ½æ–‡æœ¬æ¢è¡Œæ–¹æ³•
  private smartTextWrap(text: string, fontSize: number, maxWidth: number): string[] {
    const lines: string[] = [];
    let currentLine = '';
    let i = 0;

    // å®šä¹‰æ ‡ç‚¹ç¬¦å·è§„åˆ™
    const punctuationAtStart = /^[ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼šã€ï¼‰ã€‘ã€ã€ã€‹"'â€¦]/;
    const punctuationAtEnd = /[ï¼ˆã€ã€Œã€ã€Š"']$/;

    while (i < text.length) {
      const char = text[i];
      const testLine = currentLine + char;

      const lineWidth = this.measureTextWidth({
        text: testLine,
        fontSize: fontSize,
        fontFamily: 'HarmonyOS Sans',
        maxWidth: maxWidth
      });

      // æ£€æŸ¥æ˜¯å¦è¶…å‡ºè¡Œå®½
      if (lineWidth > maxWidth && currentLine.length > 0) {
        // éœ€è¦æ¢è¡Œï¼Œæ£€æŸ¥æ¢è¡Œè§„åˆ™
        const breakResult = this.findOptimalBreakPoint(
          text, currentLine, i, fontSize, maxWidth
        );

        lines.push(breakResult.line);
        currentLine = '';
        i = breakResult.nextIndex;
        continue;
      }

      currentLine += char;
      i++;
    }

    if (currentLine.length > 0) {
      lines.push(currentLine);
    }

    return lines;
  }

  // å¯»æ‰¾æœ€ä½³æ¢è¡Œç‚¹
  private findOptimalBreakPoint(
    fullText: string,
    currentLine: string,
    currentIndex: number,
    fontSize: number,
    maxWidth: number
  ): BreakPoint {

    // æ£€æŸ¥ä¸‹ä¸€ä¸ªå­—ç¬¦æ˜¯å¦ä¸ºæ ‡ç‚¹ç¬¦å·ï¼ˆé¿è¡Œé¦–ï¼‰
    const nextChar = fullText[currentIndex] || '';
    const punctuationAtStart = /[ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼šã€ï¼‰ã€‘ã€ã€ã€‹"'â€¦]/;
    const punctuationAtEnd = /[ï¼ˆã€ã€Œã€ã€Š"']/;

    if (punctuationAtStart.test(nextChar)) {
      // ä¸‹ä¸€ä¸ªå­—ç¬¦æ˜¯æ ‡ç‚¹ç¬¦å·ï¼Œå°è¯•å°†å…¶åŠ å…¥å½“å‰è¡Œ
      const testLine = currentLine + nextChar;
      const totalWidth = this.measureTextWidth({
        text: testLine,
        fontSize: fontSize,
        fontFamily: 'HarmonyOS Sans',
        maxWidth: maxWidth
      });

      if (totalWidth <= maxWidth) {
        return {
          line: testLine,
          nextIndex: currentIndex + 1
        };
      } else {
        // æ ‡ç‚¹æ”¾ä¸ä¸‹ï¼Œå‘å‰å›é€€
        return this.findPreviousBreakPoint(currentLine, currentIndex, fontSize, maxWidth);
      }
    }

    // æ£€æŸ¥å½“å‰è¡Œæœ«å°¾æ˜¯å¦ä¸ºä¸èƒ½æ–­è¡Œçš„æ ‡ç‚¹
    const lastChar = currentLine[currentLine.length - 1] || '';
    if (punctuationAtEnd.test(lastChar)) {
      return this.findPreviousBreakPoint(currentLine, currentIndex, fontSize, maxWidth);
    }

    // æ­£å¸¸æ–­è¡Œ
    return {
      line: currentLine,
      nextIndex: currentIndex
    };
  }

  // å‘å‰å›é€€å¯»æ‰¾æ–­ç‚¹
  private findPreviousBreakPoint(
    currentLine: string,
    currentIndex: number,
    fontSize: number,
    maxWidth: number
  ): BreakPoint {

    // ä»å½“å‰è¡Œæœ«å°¾å‘å‰å¯»æ‰¾åˆé€‚çš„æ–­ç‚¹
    for (let i = currentLine.length - 1; i > 0; i--) {
      const truncatedLine = currentLine.substring(0, i);
      const char = currentLine[i];

      const punctuationAtEnd = /[ï¼ˆã€ã€Œã€ã€Š"']/;
      const punctuationAtStart = /[ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼šã€ï¼‰ã€‘ã€ã€ã€‹"'â€¦]/;

      if (!punctuationAtEnd.test(truncatedLine[truncatedLine.length - 1] || '') &&
          !punctuationAtStart.test(char)) {

        const truncatedWidth = this.measureTextWidth({
          text: truncatedLine,
          fontSize: fontSize,
          fontFamily: 'HarmonyOS Sans',
          maxWidth: maxWidth
        });

        if (truncatedWidth <= maxWidth) {
          return {
            line: truncatedLine,
            nextIndex: currentIndex - (currentLine.length - i)
          };
        }
      }
    }

    // å®åœ¨æ‰¾ä¸åˆ°åˆé€‚æ–­ç‚¹ï¼Œå¼ºåˆ¶æ–­è¡Œ
    return {
      line: currentLine,
      nextIndex: currentIndex
    };
  }

  // æ£€æŸ¥æ˜¯å¦æœ‰å­¤è¡Œ
  private hasOrphanLines(lines: string[]): boolean {
    return lines.some(line => {
      const effectiveLength = line.replace(/[ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼šã€ï¼ˆï¼‰ã€ã€‘ã€Œã€ã€ã€ã€Šã€‹"'"'â€¦]/g, '').length;
      return effectiveLength > 0 && effectiveLength < 3;
    });
  }

  // æ£€æŸ¥æ˜¯å¦æœ‰æ ‡ç‚¹ç¬¦å·åœ¨è¡Œé¦–
  private hasPunctuationAtLineStart(lines: string[]): boolean {
    const punctuationAtStart = /^[ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼šã€ï¼‰ã€‘ã€ã€ã€‹"'â€¦]/;
    return lines.some(line => punctuationAtStart.test(line));
  }

  // ä¼˜åŒ–å­—ä½“å¤§å°ä»¥è·å¾—æœ€ä½³æ’ç‰ˆ
  private optimizeFontSizeForLayout(
    text: string,
    containerWidth: number,
    initialFontSize: number,
    maxLines: number = 20
  ): number {

    let fontSize = initialFontSize;
    let attempts = 0;
    const maxAttempts = 8;

    while (attempts < maxAttempts) {
      const lines = this.smartTextWrap(text, fontSize, containerWidth);

      // æ£€æŸ¥æ˜¯å¦ç¬¦åˆæ’ç‰ˆè¦æ±‚
      if (this.isLayoutAcceptable(lines, maxLines)) {
        break;
      }

      // å¦‚æœè¡Œæ•°å¤ªå¤šæˆ–æœ‰å­¤è¡Œï¼Œå‡å°å­—ä½“
      if (lines.length > maxLines || this.hasOrphanLines(lines)) {
        fontSize = Math.max(fontSize - 1, 14); // æœ€å°14px
      } else {
        // å¯ä»¥å°è¯•å¢å¤§å­—ä½“
        fontSize = Math.min(fontSize + 1, 40); // æœ€å¤§40px
      }

      attempts++;
    }

    return fontSize;
  }

  // æ£€æŸ¥æ’ç‰ˆæ˜¯å¦å¯æ¥å—
  private isLayoutAcceptable(lines: string[], maxLines: number): boolean {
    // æ£€æŸ¥å­¤è¡Œ
    if (this.hasOrphanLines(lines)) return false;

    // æ£€æŸ¥æ ‡ç‚¹ç¬¦å·ä½ç½®
    if (this.hasPunctuationAtLineStart(lines)) return false;

    // æ£€æŸ¥è¡Œæ•°æ˜¯å¦åˆç†
    if (lines.length > maxLines) return false;

    return true;
  }

  async aboutToAppear() {
    // ç¡®ä¿å±å¹•å°ºå¯¸é¦–å…ˆè¢«æ­£ç¡®è·å–
    await this.getScreenRatio();

    // éªŒè¯å±å¹•å°ºå¯¸è·å–æ˜¯å¦æˆåŠŸ
    console.log(`aboutToAppear - å±å¹•å°ºå¯¸ç¡®è®¤: ${this.screenWidth}x${this.screenHeight}`);

    // å¦‚æœå±å¹•å°ºå¯¸è·å–å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼
    if (this.screenWidth === 0 || this.screenHeight === 0) {
      console.warn('å±å¹•å°ºå¯¸è·å–å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼');
      this.screenWidth = 360;
      this.screenHeight = 640;
    }

    // åˆå§‹åŒ–æ–‡æœ¬å¸ƒå±€ä¼˜åŒ–å™¨
    this.textLayoutOptimizer = new TextLayoutOptimizer(this.screenWidth, this.screenHeight);

    await this.loadConfig();
    await this.loadQuoteSource();
    await this.initializeQuoteList();
    await this.updatePreview();
    await this.updateBackgroundForCurrentPage(this.currentPageIndex); // åˆå§‹åŒ–èƒŒæ™¯
    this.startHintTimer();
  }

  // åˆå§‹åŒ–åè¨€åˆ—è¡¨ï¼Œå‚è€ƒhelper6_page_turn.txtç¬¬57-65è¡Œ
  async initializeQuoteList() {
    try {
      console.log(`=== åˆå§‹åŒ–åè¨€åˆ—è¡¨ ===`);
      console.log(`å±å¹•å®½åº¦: ${this.screenWidth}px, å±å¹•é«˜åº¦: ${this.screenHeight}px`);

      // è®¡ç®—Textç»„ä»¶çš„å®é™…å¯ç”¨å®½åº¦
      // Textç»„ä»¶çˆ¶å®¹å™¨æœ‰ .padding(24)ï¼Œå³å·¦å³å„24px
      // Textç»„ä»¶è‡ªèº«æ²¡æœ‰é¢å¤–çš„padding/marginï¼ˆé™¤äº†bottom marginï¼‰
      // å®‰å…¨è¾¹è·ç°åœ¨æ ¹æ®å­—ä½“å¤§å°åŠ¨æ€è®¡ç®—ï¼šå­—ä½“å¤§å° * 4
      const parentPadding = 48; // å·¦å³å„24px

      console.log(`å±å¹•å®½åº¦: ${this.screenWidth}px`);
      console.log(`çˆ¶å®¹å™¨padding: ${parentPadding}px`);

      // åŠ è½½å½“å‰å£çº¸
      await this.loadCurrentWallpaper();

      // å¦‚æœæ²¡æœ‰å½“å‰åè¨€ï¼Œä½¿ç”¨æ¨èç³»ç»Ÿè·å–ç¬¬ä¸€ä¸ª
      if (!this.currentQuote) {
        const recommendedQuotes = await QuoteSelectionService.getRecommendedQuotes(1, this.usedQuoteTexts);
        if (recommendedQuotes && recommendedQuotes.length > 0) {
          this.currentQuote = recommendedQuotes[0];
          this.usedQuoteTexts.add(this.currentQuote.text); // æ·»åŠ åˆ°å·²ä½¿ç”¨åˆ—è¡¨
        } else {
          // å¦‚æœæ¨èç³»ç»Ÿä¹Ÿå¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤åè¨€
          this.currentQuote = {
            text: "ä¸€åˆ‡ç¾¤ä¼—çš„å®é™…ç”Ÿæ´»é—®é¢˜ï¼Œéƒ½æ˜¯æˆ‘ä»¬åº”å½“æ³¨æ„çš„é—®é¢˜",
            author: "æ¯›æ³½ä¸œ",
            category: "ç¾¤ä¼—",
            source: "ã€Šå…³å¿ƒç¾¤ä¼—ç”Ÿæ´»ï¼Œæ³¨æ„å·¥ä½œæ–¹æ³•ã€‹"
          };
        }
      }

      // å…ˆåŠ è½½å½“å‰åè¨€
      this.quoteDataSource.pushItem(this.currentQuote);

      // å¦‚æœæ²¡æœ‰å½“å‰å£çº¸ï¼Œç”Ÿæˆä¸€ä¸ª
      if (!this.currentWallpaper) {
        this.currentWallpaper = await WallpaperService.generateWallpaper(this.currentQuote);
      }
      this.wallpaperList.push(this.currentWallpaper);

      // é¢„å¤„ç†å½“å‰åè¨€çš„å­—ä½“å¤§å°
      const initialFontSize = this.currentWallpaper?.style.fontSize || 24;
      console.log(`ä½¿ç”¨åˆå§‹å­—ä½“å¤§å°: ${initialFontSize}px`);

      // é‡æ–°è®¡ç®—åŸºäºå­—ä½“å¤§å°çš„å®‰å…¨è¾¹è·å’Œå®¹å™¨å®½åº¦
      const dynamicSafetyMargin = initialFontSize * 5; // å­—ä½“å¤§å° * 5
      const dynamicRawContainerWidth = this.screenWidth - parentPadding - dynamicSafetyMargin;
      const dynamicContainerWidth = Math.max(dynamicRawContainerWidth, 200);

      console.log(`åŠ¨æ€å®‰å…¨è¾¹è·: ${dynamicSafetyMargin}px (åŸºäºå­—ä½“${initialFontSize}px)`);
      console.log(`åŠ¨æ€å®¹å™¨å®½åº¦: ${dynamicContainerWidth}px`);

      const textLayout = this.formatQuoteText(this.currentQuote.text, initialFontSize, dynamicContainerWidth);
      this.optimizedFontSizes.push(textLayout.fontSize);

      console.log(`=== å½“å‰quoteå¤„ç†å®Œæˆ ===`);
      console.log(`ä¼˜åŒ–åå­—ä½“å¤§å°: ${textLayout.fontSize}px`);
      console.log(`ä¼˜åŒ–åæ–‡æœ¬:\n${textLayout.text}`);

      // é¢„åŠ è½½æ›´å¤šæ¨èåè¨€
      console.log(`=== å¼€å§‹åŠ è½½æ¨èåè¨€ ===`);
      const moreQuotes = await QuoteSelectionService.getRecommendedQuotes(10, this.usedQuoteTexts);
      if (moreQuotes && moreQuotes.length > 0) {
        for (const quote of moreQuotes) {
          this.quoteDataSource.pushItem(quote);
          this.usedQuoteTexts.add(quote.text); // æ·»åŠ åˆ°å·²ä½¿ç”¨åˆ—è¡¨
          const wallpaper = await WallpaperService.generateWallpaper(quote);
          this.wallpaperList.push(wallpaper);

          // é¢„å¤„ç†å­—ä½“å¤§å°
          const quoteFontSize = wallpaper?.style.fontSize || 24;
          // ä¸ºæ¯ä¸ªquoteè®¡ç®—åŠ¨æ€å®‰å…¨è¾¹è·å’Œå®¹å™¨å®½åº¦
          const quoteSafetyMargin = quoteFontSize * 5; // å­—ä½“å¤§å° * 5
          const quoteRawContainerWidth = this.screenWidth - parentPadding - quoteSafetyMargin;
          const quoteContainerWidth = Math.max(quoteRawContainerWidth, 200);
          const quoteLayout = this.formatQuoteText(quote.text, quoteFontSize, quoteContainerWidth);
          this.optimizedFontSizes.push(quoteLayout.fontSize);
        }
        console.log(`åŠ è½½äº†${moreQuotes.length}æ¡æ¨èåè¨€`);
      }
    } catch (error) {
      console.error('Failed to initialize quote list:', error);
    }
  }

  async loadQuoteSource() {
    try {
      const QuoteDataModule = await import('../common/QuoteData');
      await QuoteDataModule.QuoteData.loadQuoteSource();
    } catch (error) {
      console.error('Failed to load quote source in Index:', error);
    }
  }

  // å¯åŠ¨æç¤ºæ–‡å­—å®šæ—¶å™¨
  startHintTimer() {
    this.clearHintTimer();
    this.hintTimer = setTimeout(() => {
      this.showHint();
    }, 4000);
  }

  // æ¸…é™¤æç¤ºæ–‡å­—å®šæ—¶å™¨
  clearHintTimer() {
    if (this.hintTimer !== -1) {
      clearTimeout(this.hintTimer);
      this.hintTimer = -1;
    }
  }

  // æ¸…é™¤é—ªçƒå®šæ—¶å™¨
  clearBlinkTimer() {
    if (this.blinkTimer !== -1) {
      clearTimeout(this.blinkTimer);
      this.blinkTimer = -1;
    }
  }

  // æ˜¾ç¤ºæç¤ºæ–‡å­—
  showHint() {
    animateTo({
      duration: 2000,
      curve: Curve.EaseInOut,
      onFinish: () => {
        // æ¸å…¥åŠ¨ç”»å®Œæˆåå¼€å§‹é—ªçƒæ•ˆæœ
        this.startBlinkEffect();
      }
    }, () => {
      this.hintOpacity = 0.8;
    });
  }

  // å¼€å§‹é—ªçƒæ•ˆæœ
  startBlinkEffect() {
    // ç§»é™¤é€æ˜åº¦æ£€æŸ¥ï¼Œå› ä¸ºå‘¼å¸å¾ªç¯ä¼šæ”¹å˜é€æ˜åº¦
    this.isBlinking = true;
    this.blinkCycle();
  }

  // å‘¼å¸å¾ªç¯ï¼ˆæ¨¡ä»¿äººç±»å¹³é™å‘¼å¸ï¼‰
  blinkCycle() {
    if (!this.isBlinking) {
      // å¦‚æœä¸åœ¨é—ªçƒçŠ¶æ€ï¼Œåœæ­¢å‘¼å¸
      return;
    }

    // ç¬¬ä¸€é˜¶æ®µï¼šé™æ­¢ç­‰å¾…2ç§’ï¼ˆå‘¼å¸é—´éš™ï¼‰
    this.blinkTimer = setTimeout(() => {
      if (!this.isBlinking) return;

      // ç¬¬äºŒé˜¶æ®µï¼šç¼“æ…¢"å‘¼æ°”"3ç§’
      animateTo({
        duration: 3000,
        curve: Curve.EaseInOut, // å¹³ç¼“çš„ç¼“åŠ¨æ›²çº¿ï¼Œæ¨¡ä»¿è‡ªç„¶å‘¼å¸
        onFinish: () => {
          // å‘¼æ°”åŠ¨ç”»å®Œæˆåï¼Œå¼€å§‹åº•éƒ¨åœé¡¿
          if (!this.isBlinking) return;

          // ç¬¬ä¸‰é˜¶æ®µï¼šåº•éƒ¨åœé¡¿5ç§’
          setTimeout(() => {
            if (!this.isBlinking) return;

            // ç¬¬å››é˜¶æ®µï¼šç¼“æ…¢"å¸æ°”"2.5ç§’ï¼Œä»0.1æ¢å¤åˆ°0.8
            animateTo({
              duration: 2500,
              curve: Curve.EaseInOut,
              onFinish: () => {
                // å®Œæˆä¸€è½®å‘¼å¸åç»§ç»­ä¸‹ä¸€è½®
                if (this.isBlinking) {
                  this.blinkCycle();
                }
              }
            }, () => {
              this.hintOpacity = 0.8;
            });
          }, 500); // åº•éƒ¨åœé¡¿0.5ç§’
        }
      }, () => {
        this.hintOpacity = 0.1;
      });
    }, 2000); // åˆå§‹é™æ­¢2ç§’
  }

  // åœæ­¢é—ªçƒæ•ˆæœ
  stopBlinkEffect() {
    this.isBlinking = false;
    this.clearBlinkTimer();
  }

  // éšè—æç¤ºæ–‡å­—
  hideHint() {
    // åœæ­¢é—ªçƒæ•ˆæœ
    this.stopBlinkEffect();

    // åªæœ‰åœ¨å½“å‰æ˜¾ç¤ºçŠ¶æ€ä¸‹æ‰æ‰§è¡Œéšè—åŠ¨ç”»
    if (this.hintOpacity > 0) {
      // æ·»åŠ çŸ­æš‚å»¶è¿Ÿï¼Œç¡®ä¿å‘¼å¸åŠ¨ç”»å®Œå…¨åœæ­¢
      setTimeout(() => {
        animateTo({
          duration: 1000,
          curve: Curve.EaseInOut
        }, () => {
          this.hintOpacity = 0;
        });
      }, 50); // 50mså»¶è¿Ÿç¡®ä¿çŠ¶æ€åŒæ­¥
    }
  }

  // é‡ç½®æç¤ºæ–‡å­—å®šæ—¶å™¨ï¼ˆå¸¦é˜²æŠ–ï¼‰
  resetHintTimer() {
    // åœæ­¢é—ªçƒæ•ˆæœ
    this.stopBlinkEffect();

    // æ¸…é™¤é˜²æŠ–å®šæ—¶å™¨
    if (this.debounceTimer !== -1) {
      clearTimeout(this.debounceTimer);
    }

    // è®¾ç½®é˜²æŠ–ï¼Œ200mså†…çš„è¿ç»­æ“ä½œåªæ‰§è¡Œæœ€åä¸€æ¬¡
    this.debounceTimer = setTimeout(() => {
      // ç«‹å³æ¸…é™¤å®šæ—¶å™¨ï¼Œé¿å…é‡å¤è§¦å‘
      this.clearHintTimer();
      // åªæœ‰åœ¨æ˜¾ç¤ºçŠ¶æ€ä¸‹æ‰æ‰§è¡Œéšè—åŠ¨ç”»
      this.hideHint();
      // é‡æ–°å¯åŠ¨å®šæ—¶å™¨
      this.startHintTimer();
      this.debounceTimer = -1;
    }, 200);
  }

  async getScreenRatio() {
    try {
      const defaultDisplay = display.getDefaultDisplaySync();
      // è®¡ç®—ç«–å±æ¯”ä¾‹ï¼ˆé«˜åº¦/å®½åº¦ï¼‰
      this.screenRatio = defaultDisplay.height / defaultDisplay.width;
      this.screenWidth = defaultDisplay.width;
      this.screenHeight = defaultDisplay.height;
      console.log(`Screen ratio: ${this.screenRatio} (${defaultDisplay.width}x${defaultDisplay.height})`);
    } catch (error) {
      console.error('Failed to get screen ratio:', error);
      this.screenRatio = 16/9; // ä¿æŒé»˜è®¤æ¯”ä¾‹
      this.screenWidth = 360;
      this.screenHeight = 640;
    }
  }

  async loadConfig() {
    try {
      this.config = await ScheduleConfig.getConfig();
    } catch (error) {
      console.error('Failed to load config:', error);
    }
  }

  async loadCurrentWallpaper() {
    this.currentWallpaper = await WallpaperService.getCurrentWallpaper();
    if (!this.currentWallpaper && this.config) {
      try {
        const selectedQuote = await QuoteSelectionService.selectQuote(this.config.selectionAlgorithm);
        this.currentQuote = selectedQuote;
        this.currentWallpaper = await WallpaperService.generateWallpaper(selectedQuote);
      } catch (error) {
        console.error('Failed to load initial wallpaper:', error);
      }
    }
  }

  // è·å–å½“å‰é¡µé¢çš„åè¨€å’Œå£çº¸
  getCurrentQuote(): Quote | null {
    if (this.quoteDataSource.totalCount() > this.currentPageIndex) {
      return this.quoteDataSource.getData(this.currentPageIndex);
    }
    return this.currentQuote;
  }

  getCurrentWallpaper(): GeneratedWallpaper | null {
    if (this.wallpaperList.length > this.currentPageIndex) {
      return this.wallpaperList[this.currentPageIndex];
    }
    return this.currentWallpaper;
  }


  async updatePreview() {
    try {
      // è®¾ç½®è¿‡æ¸¡çŠ¶æ€ï¼Œç¦ç”¨æ‰‹åŠ¿å“åº”
      this.isTransitioning = true;

      let newBackground = '#2c3e50';
      const currentWallpaper = this.getCurrentWallpaper();

      if (currentWallpaper) {
        const previewResult = WallpaperService.createWallpaperPreview(currentWallpaper);
        if (previewResult) {
          newBackground = previewResult;
        } else {
          newBackground = currentWallpaper.style.backgroundColor || '#2c3e50';
        }
      }

      // å†…å®¹æ·¡å‡º -> æ›´æ–°èƒŒæ™¯å’Œå†…å®¹ -> å†…å®¹æ·¡å…¥
      // ç¬¬ä¸€é˜¶æ®µï¼šå†…å®¹æ·¡å‡º
      animateTo({
        duration: 250,
        curve: Curve.EaseInOut
      }, () => {
        this.contentOpacity = 0;
      });

      // ç¬¬äºŒé˜¶æ®µï¼šæ›´æ–°èƒŒæ™¯ï¼Œç„¶åå†…å®¹æ·¡å…¥
      setTimeout(() => {
        animateTo({
          duration: 250,
          curve: Curve.EaseInOut
        }, () => {
          this.previewBackground = newBackground;
          this.contentOpacity = 1;
        });

        // åŠ¨ç”»å®Œæˆåæ¢å¤æ‰‹åŠ¿å“åº”
        setTimeout(() => {
          this.isTransitioning = false;
        }, 250);
      }, 250);

      setTimeout(() => {
        console.log('Preview updated:', this.previewBackground);
      }, 0);
    } catch (error) {
      console.error('Failed to update preview:', error);
      animateTo({
        duration: 500,
        curve: Curve.EaseInOut
      }, () => {
        this.previewBackground = '#2c3e50';
        this.contentOpacity = 1;
      });

      // é”™è¯¯æƒ…å†µä¸‹ä¹Ÿè¦æ¢å¤æ‰‹åŠ¿å“åº”
      setTimeout(() => {
        this.isTransitioning = false;
      }, 500);
    }
  }

  // é¡µé¢æ»šåŠ¨æ—¶çš„å›è°ƒï¼Œå‚è€ƒhelper6_page_turn.txtç¬¬101-103è¡Œ
  onScrollIndex(firstIndex: number) {
    this.currentPageIndex = firstIndex;
    console.log('Current page index:', this.currentPageIndex);
    // å¼‚æ­¥åŠ è½½æ›´å¤šå†…å®¹
    this.loadMoreIfNeeded(firstIndex);
  }

  // æŒ‰éœ€åŠ è½½æ›´å¤šå†…å®¹
  async loadMoreIfNeeded(currentIndex: number) {
    const totalCount = this.quoteDataSource.totalCount();

    // é™åˆ¶æœ€å¤šåŠ è½½100æ¡å†…å®¹
    if (totalCount >= 100) {
      console.log('å·²è¾¾åˆ°æœ€å¤§åŠ è½½æ•°é‡é™åˆ¶(100æ¡)');
      return;
    }

    // å½“æ»šåŠ¨åˆ°å€’æ•°ç¬¬3é¡¹æ—¶ï¼Œé¢„åŠ è½½æ›´å¤šå†…å®¹
    if (currentIndex >= totalCount - 3) {
      try {
        // è®¡ç®—è¿˜èƒ½åŠ è½½å¤šå°‘æ¡ï¼Œé¿å…è¶…è¿‡100æ¡é™åˆ¶
        const remainingCount = 100 - totalCount;
        const loadCount = Math.min(10, remainingCount); // é¢„åŠ è½½5æ¡æˆ–å‰©ä½™æ•°é‡
        const parentPadding = 48; // å·¦å³å„24px padding

        for (let i = 0; i < loadCount; i++) {
          const recommendedQuotes = await QuoteSelectionService.getRecommendedQuotes(1, this.usedQuoteTexts);
          if (recommendedQuotes && recommendedQuotes.length > 0) {
            const quote = recommendedQuotes[0];
            this.quoteDataSource.pushItem(quote);
            this.usedQuoteTexts.add(quote.text); // æ·»åŠ åˆ°å·²ä½¿ç”¨åˆ—è¡¨
            const wallpaper = await WallpaperService.generateWallpaper(quote);
            this.wallpaperList.push(wallpaper);

            // é¢„å¤„ç†å­—ä½“å¤§å°
            const quoteFontSize = wallpaper?.style.fontSize || 24;
            // ä¸ºæ¯ä¸ªquoteè®¡ç®—åŠ¨æ€å®‰å…¨è¾¹è·å’Œå®¹å™¨å®½åº¦
            const quoteSafetyMargin = quoteFontSize * 5; // å­—ä½“å¤§å° * 5
            const quoteRawContainerWidth = this.screenWidth - parentPadding - quoteSafetyMargin;
            const quoteContainerWidth = Math.max(quoteRawContainerWidth, 200);
            const quoteLayout = this.formatQuoteText(quote.text, quoteFontSize, quoteContainerWidth);
            this.optimizedFontSizes.push(quoteLayout.fontSize);
          }
        }

        console.log(`åŠ è½½äº†${loadCount}æ¡å†…å®¹ï¼Œå½“å‰æ€»æ•°ï¼š${this.quoteDataSource.totalCount()}`);
      } catch (error) {
        console.error('Failed to load more quotes:', error);
      }
    }
  }

  // æ›´æ–°å½“å‰é¡µé¢çš„èƒŒæ™¯é¢œè‰²
  async updateBackgroundForCurrentPage(index: number) {
    try {
      let newBackground = '#2c3e50';

      if (this.wallpaperList.length > index && this.wallpaperList[index] !== null) {
        const wallpaper = this.wallpaperList[index];
        if (wallpaper) {
          const previewResult = WallpaperService.createWallpaperPreview(wallpaper);
          if (previewResult) {
            newBackground = previewResult;
          } else {
            newBackground = wallpaper.style.backgroundColor || '#2c3e50';
          }
        }
      }

      // ä½¿ç”¨åŠ¨ç”»æ›´æ–°èƒŒæ™¯
      animateTo({
        duration: 300,
        curve: Curve.EaseInOut
      }, () => {
        this.previewBackground = newBackground;
      });

      console.log('Background updated for page:', index, newBackground);
    } catch (error) {
      console.error('Failed to update background for current page:', error);
    }
  }


  async applyWallpaperOptions() {
    if (!this.setLockScreen && !this.saveToGallery) {
      this.showSaveDialog = false;
      return;
    }

    this.isApplying = true;

    try {
      console.log('å¼€å§‹åº”ç”¨å£çº¸æ“ä½œ...');

      // ä½¿ç”¨componentSnapshot APIæˆªå›¾çº¯å‡€å£çº¸åŒºåŸŸ
      componentSnapshot.get("pureWallpaperArea", async (error: Error, pixelMap: image.PixelMap) => {
        if (error) {
          console.error("æˆªå›¾å¤±è´¥: " + JSON.stringify(error));
          this.isApplying = false;
          this.showSaveDialog = false;
          return;
        }

        try {
          // å°†PixelMapä¿å­˜ä¸ºJPEGæ ¼å¼
          const packOpts: image.PackingOption = {
            format: "image/jpeg",
            quality: 98
          };

          const imagePacker: image.ImagePacker = image.createImagePacker();
          const arrayBuffer: ArrayBuffer = await imagePacker.packing(pixelMap, packOpts);

          // åˆ›å»ºä¸´æ—¶æ–‡ä»¶
          const context = getContext(this) as common.UIAbilityContext;
          const filesDir: string = context.filesDir;
          const tempImagePath = `${filesDir}/temp_wallpaper_${Date.now()}.jpg`;

          // ä¿å­˜ä¸´æ—¶æ–‡ä»¶
          const file = await fs.open(tempImagePath, fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);
          await fs.write(file.fd, arrayBuffer);
          await fs.close(file.fd);

          // æ‰§è¡Œé€‰å®šçš„æ“ä½œ
          const results = await WallpaperService.applyWallpaperOperations(
            tempImagePath,
            this.setLockScreen,
            this.saveToGallery
          );

          // æ˜¾ç¤ºç»“æœ
          let message = '';
          if (this.setLockScreen && results.lockScreenSuccess) {
            message += 'é”å±å£çº¸è®¾ç½®æˆåŠŸï¼';
          } else if (this.setLockScreen && !results.lockScreenSuccess) {
            message += 'é”å±å£çº¸è®¾ç½®å¤±è´¥ï¼';
          }

          if (this.saveToGallery && results.gallerySuccess) {
            if (message) message += '\n';
            message += 'å›¾ç‰‡å·²ä¿å­˜åˆ°å›¾åº“ï¼';
          } else if (this.saveToGallery && !results.gallerySuccess) {
            if (message) message += '\n';
            message += 'å›¾ç‰‡ä¿å­˜åˆ°å›¾åº“å¤±è´¥ï¼';
          }

          console.log('å£çº¸æ“ä½œå®Œæˆ:', message);

          // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
          try {
            await fs.unlink(tempImagePath);
          } catch (unlinkError) {
            console.error('æ¸…ç†ä¸´æ—¶æ–‡ä»¶å¤±è´¥:', unlinkError);
          }

          // é‡Šæ”¾èµ„æº
          imagePacker.release();
          pixelMap.release();

        } catch (packError) {
          console.error('å›¾ç‰‡å¤„ç†å¤±è´¥:', packError);
          pixelMap.release();
        } finally {
          this.isApplying = false;
          this.showSaveDialog = false;
        }
      });

    } catch (error) {
      console.error('åº”ç”¨å£çº¸å¤±è´¥:', error);
      this.isApplying = false;
      this.showSaveDialog = false;
    }
  }

  /**
   * æ™ºèƒ½æ ¼å¼åŒ–åè¨€æ–‡æœ¬ï¼Œé¿å…å­¤è¡Œå’Œæ ‡ç‚¹ç¬¦å·è¡Œé¦–
   * @param text åŸå§‹æ–‡æœ¬
   * @param fontSize å­—ä½“å¤§å°
   * @param containerWidth å®¹å™¨å®½åº¦
   * @returns æ ¼å¼åŒ–åçš„æ–‡æœ¬å¸ƒå±€ç»“æœ
   */
  formatQuoteText(text: string, fontSize?: number, containerWidth?: number): TextLayoutResult {
    // å¦‚æœæ²¡æœ‰æä¾›å‚æ•°æˆ–ä¼˜åŒ–å™¨æœªåˆå§‹åŒ–ï¼Œä½¿ç”¨ç®€å•å¤„ç†
    if (!fontSize || !containerWidth || !this.textLayoutOptimizer) {
      // é™çº§åˆ°åŸæœ‰çš„ç®€å•æ¢è¡Œé€»è¾‘
      const simpleFormatted = text
        .replace(/([ï¼Œ,])\s*/g, '$1\n')
        .replace(/([ã€‚ï¼ï¼Ÿï¼›ï¼š])\s*/g, '$1\n \n')
        .replace(/([.!?;:])\s*/g, '$1\n \n')
        .replace(/\n{3,}/g, '\n \n')
        .replace(/\s*\n\s*/g, '\n')
        .trim();

      return {
        text: simpleFormatted,
        fontSize: fontSize || 24,
        lines: simpleFormatted.split('\n')
      };
    }

    // ä½¿ç”¨æ–°çš„æ™ºèƒ½ä¼˜åŒ–ç®—æ³•
    try {
      console.log(`Starting text layout optimization for: "${text.substring(0, 20)}..."`);
      const result = this.textLayoutOptimizer.optimizeLayout(text, containerWidth, fontSize);
      console.log(`Optimization completed. Font size: ${result.fontSize}, Lines: ${result.lines.length}`);
      return result;
    } catch (error) {
      console.error('Advanced text optimization failed, fallback to simple formatting:', error);

      // å‡ºé”™æ—¶é™çº§åˆ°ç®€å•å¤„ç†
      const simpleFormatted = text
        .replace(/([ï¼Œ,])\s*/g, '$1\n')
        .replace(/([ã€‚ï¼ï¼Ÿï¼›ï¼š])\s*/g, '$1\n \n')
        .replace(/([.!?;:])\s*/g, '$1\n \n')
        .replace(/\n{3,}/g, '\n \n')
        .replace(/\s*\n\s*/g, '\n')
        .trim();

      return {
        text: simpleFormatted,
        fontSize: fontSize,
        lines: simpleFormatted.split('\n')
      };
    }
  }

  async saveImageToPhoto(buffer: ArrayBuffer): Promise<void> {
    // æŒ‰ç…§ _helper.txt ç¬¬86-94è¡Œçš„æ–¹æ³•å®ç°
    const context = getContext(this) as common.UIAbilityContext;
    const helper = photoAccessHelper.getPhotoAccessHelper(context);
    const uri = await helper.createAsset(photoAccessHelper.PhotoType.IMAGE, 'jpg');
    const file = await fs.open(uri, fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);
    await fs.write(file.fd, buffer);
    await fs.close(file.fd);
    console.log("å›¾ç‰‡ä¿å­˜æˆåŠŸåˆ°ç›¸å†Œ:", uri);
  }

  build() {
    // å…¨å±é¢„è§ˆåŒºåŸŸ
    Stack() {
      // èƒŒæ™¯é¢„è§ˆåŒºåŸŸï¼ˆå¡«æ»¡æ•´ä¸ªå±å¹•ï¼‰
      Column()
        .width('100%')
        .height('100%')
        .backgroundColor(this.previewBackground || '#667eea')
        .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])

      // ä¸Šä¸‹ç¿»é¡µçš„åè¨€æ–‡æœ¬å±‚ï¼Œä½¿ç”¨Swiperå®ç°åˆ†é¡µæ•ˆæœï¼Œå‚è€ƒhelper6_page_turn.txtç¬¬38-54è¡Œ
      Swiper() {
        LazyForEach(this.quoteDataSource, (quote: Quote, index: number) => {
          Column() {
            Text(this.formatQuoteText(quote.text).text)
              .fontSize(this.optimizedFontSizes[index] || (this.wallpaperList[index]?.style.fontSize) || 24)
              .fontColor((this.wallpaperList[index]?.style.textColor) || '#d3d3d3')
              .textAlign(TextAlign.Center)
              .width('100%')
              .margin({ bottom: 40 })
              .maxLines(20)
              .textOverflow({ overflow: TextOverflow.None })

            Text(`â€”â€” ${quote.author || ''}${(quote.author && quote.source) ? ' Â· ' : ''}${quote.source || ''}`)
              .fontSize(12)
              .fontColor((this.wallpaperList[index]?.style.textColor) || '#d3d3d3')
              .opacity(0.8)
              .textAlign(TextAlign.Center)
              .width('100%')
          }
          .justifyContent(FlexAlign.Center)
          .alignItems(HorizontalAlign.Center)
          .padding(24)
          .width('100%')
          .height('100%')
        }, (quote: Quote, index: number) => `${quote.text}-${index}`)
      }
      .index(this.currentPageIndex)
      .width('100%')
      .height('100%')
      .indicator(false) // éšè—æŒ‡ç¤ºå™¨
      .vertical(true) // è®¾ç½®ä¸ºå‚ç›´æ–¹å‘æ»‘åŠ¨
      .loop(false) // ç¦ç”¨å¾ªç¯æ»šåŠ¨ï¼Œé˜²æ­¢åœ¨è¾¹ç•Œæ—¶ç»§ç»­æ»‘åŠ¨
      .cachedCount(3) // å‚è€ƒhelper6_page_turn.txtç¬¬53è¡Œï¼Œè®¾ç½®ç¼“å­˜æ•°é‡
      .onChange((index: number) => {
        // ç¡®ä¿ç´¢å¼•åœ¨æœ‰æ•ˆèŒƒå›´å†…
        if (index >= 0 && index < this.quoteDataSource.totalCount()) {
          this.onScrollIndex(index);
          this.updateBackgroundForCurrentPage(index);
          this.resetHintTimer(); // æ»‘åŠ¨åˆ‡æ¢æ—¶é‡ç½®æç¤ºæ–‡å­—å®šæ—¶å™¨
        }
      })
      .onGestureSwipe((index: number, extraInfo: SwiperAnimationEvent) => {
        this.resetHintTimer(); // æ»‘åŠ¨æ‰‹åŠ¿å¼€å§‹æ—¶ç«‹å³é‡ç½®æç¤ºæ–‡å­—å®šæ—¶å™¨
      })
      .onAnimationStart((index: number, targetIndex: number, extraInfo: SwiperAnimationEvent) => {
        // é˜²æ­¢å‘å‰æ»‘åŠ¨è¶…å‡ºè¾¹ç•Œ
        if (targetIndex < 0) {
          console.log('é˜²æ­¢å‘å‰æ»‘åŠ¨è¶…å‡ºè¾¹ç•Œ');
          return;
        }
        // é˜²æ­¢å‘åæ»‘åŠ¨è¶…å‡ºè¾¹ç•Œ
        if (targetIndex >= this.quoteDataSource.totalCount()) {
          console.log('é˜²æ­¢å‘åæ»‘åŠ¨è¶…å‡ºè¾¹ç•Œ');
          return;
        }
      })

      // é¡¶éƒ¨æ ‡é¢˜æ  - åŠé€æ˜å±‚
      Row() {
        Blank()

        Button() {
          Text('...')
            .fontSize(18)
            .fontColor('#ffffff')
        }
        .width(40)
        .height(40)
        .backgroundColor('rgba(255, 255, 255, 0)')
        .borderRadius(20)
        .backdropBlur(10)
        .onClick(() => {
          router.pushUrl({
            url: 'pages/Settings'
          });
        })
      }
      .width('100%')
      .height(60)
      .padding({ left: 20, right: 20, top: 10, bottom: 10 })
      .backgroundColor('rgba(0, 0, 0, 0)')
      .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP])
      .position({ x: 0, y: 0 })

      // åº•éƒ¨æç¤ºæ–‡å­— - åŠé€æ˜å±‚
      Column() {
        Text('ä¸Šä¸‹æ»‘åŠ¨åˆ‡æ¢ Â· é•¿æŒ‰ä¿å­˜')
          .fontSize(14)
          .fontColor('#ffffff')
          .textAlign(TextAlign.Center)
          .padding({ top: 12, bottom: 12, left: 24, right: 24 })
          .borderRadius(12)
      }
      .width('100%')
      .padding({ left: 20, right: 20, bottom: 30, top: 20 })
      .backgroundColor('rgba(0, 0, 0, 0)')
      .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])
      .position({ x: 0, y: '100%' })
      .translate({ y: '-100%' })
      .opacity(this.hintOpacity)

      // å…¨å±åŠ è½½é®ç½©
      if (this.isLoading) {
        Stack() {
          Column()
            .width('100%')
            .height('100%')
            .backgroundColor('rgba(0, 0, 0, 0.4)')
            .backdropBlur(10)

          Column() {
            LoadingProgress()
              .width(50)
              .height(50)
              .margin({ bottom: 16 })

            Text('æ­£åœ¨ç”Ÿæˆå£çº¸...')
              .fontSize(18)
              .fontColor('#ffffff')
          }
          .justifyContent(FlexAlign.Center)
          .alignItems(HorizontalAlign.Center)
          .width(140)
          .height(140)
          .backgroundColor('rgba(44, 62, 80, 0.8)')
          .borderRadius(16)
          .backdropBlur(20)
        }
        .width('100%')
        .height('100%')
      }
      // éšè—çš„çº¯å‡€å£çº¸ç»„ä»¶ç”¨äºæˆªå›¾
      this.buildPureWallpaper()
    }
    .width('100%')
    .height('100%')
    .id('previewArea')
    .gesture(
      // é•¿æŒ‰æ‰‹åŠ¿ï¼šä¿å­˜å£çº¸
      LongPressGesture({ fingers: 1, repeat: false, duration: 800 })
        .onAction(() => {
          this.resetHintTimer(); // é•¿æŒ‰æ—¶é‡ç½®æç¤ºæ–‡å­—å®šæ—¶å™¨
          this.showSaveDialog = true;
        })
    )
    .bindContentCover(this.showSaveDialog, this.buildSaveDialog(), ModalTransition.NONE)
  }


  @Builder
  buildSaveDialog() {
    Column() {
      Column() {
        Text('åº”ç”¨å£çº¸')
          .fontSize(20)
          .fontWeight(FontWeight.Bold)
          .fontColor('#2c3e50')
          .margin({ bottom: 16 })

        Text('è¯·é€‰æ‹©è¦æ‰§è¡Œçš„æ“ä½œï¼š')
          .fontSize(16)
          .fontColor('#7f8c8d')
          .textAlign(TextAlign.Center)
          .margin({ bottom: 20 })

        // é€‰é¡¹åŒºåŸŸ
        Column() {
          Column() {
            Row() {
              Checkbox({ name: 'setLockScreen', group: 'wallpaperOptions' })
                .select(this.setLockScreen)
                .selectedColor('#5b9bd5')
                .onChange((value: boolean) => {
                  this.setLockScreen = value;
                })
                .margin({ right: 12 })
                .enabled(false)

              Text('è®¾ç½®ä¸ºç³»ç»Ÿé”å±å£çº¸')
                .fontSize(16)
                .fontColor('#bdc3c7')
                .flexGrow(1)
            }
            .width('100%')
            .alignItems(VerticalAlign.Center)
            .padding({ top: 8, bottom: 4 })

            Text('å®˜æ–¹å·²ä¸æ”¯æŒè¯¥åŠŸèƒ½ï¼Œéœ€ä¿å­˜å›¾ç‰‡åæ‰‹åŠ¨è®¾ç½®')
              .fontSize(12)
              .fontColor('#95a5a6')
              .width('100%')
              .margin({ left: 32, bottom: 4 })
          }

          Row() {
            Checkbox({ name: 'saveToGallery', group: 'wallpaperOptions' })
              .select(this.saveToGallery)
              .selectedColor('#5b9bd5')
              .onChange((value: boolean) => {
                this.saveToGallery = value;
              })
              .margin({ right: 12 })

            Text('ä¿å­˜åˆ°ç³»ç»Ÿå›¾åº“')
              .fontSize(16)
              .fontColor('#2c3e50')
              .flexGrow(1)
              .onClick(() => {
                this.saveToGallery = !this.saveToGallery;
              })
          }
          .width('100%')
          .alignItems(VerticalAlign.Center)
          .padding({ top: 8, bottom: 8 })
        }
        .margin({ bottom: 24 })

        Row() {
          Button('å–æ¶ˆ')
            .width('45%')
            .height(40)
            .backgroundColor('#ffffff')
            .fontColor('#7f8c8d')
            .borderRadius(6)
            .border({ width: 1, color: '#bdc3c7' })
            .enabled(!this.isApplying)
            .onClick(() => {
              this.showSaveDialog = false;
            })

          Button() {
            if (this.isApplying) {
              Row() {
                LoadingProgress()
                  .width(16)
                  .height(16)
                  .color('#ffffff')
                  .margin({ right: 8 })
                Text('åº”ç”¨ä¸­...')
                  .fontSize(14)
                  .fontColor('#ffffff')
              }
            } else {
              Text('ç¡®å®š')
                .fontSize(16)
                .fontColor('#ffffff')
            }
          }
          .width('45%')
          .height(40)
          .backgroundColor('#5b9bd5')
          .borderRadius(6)
          .margin({ left: '10%' })
          .enabled(!this.isApplying && (this.setLockScreen || this.saveToGallery))
          .onClick(async () => {
            await this.applyWallpaperOptions();
          })
        }
        .width('100%')
        .justifyContent(FlexAlign.SpaceBetween)
      }
      .width('85%')
      .padding(24)
      .backgroundColor('#ffffff')
      .borderRadius(12)
      .shadow({
        radius: 16,
        color: '#00000020',
        offsetX: 0,
        offsetY: 8
      })
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#00000050')
    .justifyContent(FlexAlign.Center)
    .alignItems(HorizontalAlign.Center)
    .onClick(() => {
      if (!this.isApplying) {
        this.showSaveDialog = false;
      }
    })
  }

  @Builder
  buildPureWallpaper() {
    // çº¯å‡€çš„å£çº¸ç»„ä»¶ï¼ŒåªåŒ…å«èƒŒæ™¯è‰²å’Œæ–‡å­—ï¼Œç”¨äºæˆªå›¾ä¿å­˜
    // æ³¨æ„ï¼šæˆªå›¾ç»„ä»¶ä¸ä½¿ç”¨åŠ¨ç”»ï¼Œå§‹ç»ˆæ˜¾ç¤ºå®Œæ•´å†…å®¹
    Column() {
      if (this.getCurrentQuote()) {
        // æ˜¾ç¤ºå½“å‰é¡µé¢çš„å†…å®¹
        Text(this.formatQuoteText(this.getCurrentQuote()?.text || '').text)
          .fontSize(this.optimizedFontSizes[this.currentPageIndex] || (this.getCurrentWallpaper()?.style.fontSize) || 24)
          .fontColor((this.getCurrentWallpaper()?.style.textColor) || '#d3d3d3')
          .textAlign(TextAlign.Center)
          .width('100%')
          .margin({ bottom: 40 })
          .maxLines(20)
          .textOverflow({ overflow: TextOverflow.None })

        Text(`â€”â€” ${this.getCurrentQuote()?.author || ''}${(this.getCurrentQuote()?.author && this.getCurrentQuote()?.source) ? ' Â· ' : ''}${this.getCurrentQuote()?.source || ''}`)
          .fontSize(12)
          .fontColor((this.getCurrentWallpaper()?.style.textColor) || '#d3d3d3')
          .opacity(0.8)
          .textAlign(TextAlign.Center)
          .width('100%')
      }
    }
    .justifyContent(FlexAlign.Center)
    .alignItems(HorizontalAlign.Center)
    .padding(24)
    .width('100%')
    .height('100%')
    .backgroundColor(this.previewBackground || '#667eea')
    .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])
    .id('pureWallpaperArea')
    .position({ x: -2000, y: 0 }) // ç§»åˆ°å±å¹•å¤–ï¼Œä¸å¯è§ä½†å¯ä»¥æˆªå›¾
  }
}